use std::{fs, process::Command};

use dialoguer::{Input, MultiSelect};

use colored::Colorize;

fn main() {
    let args: Vec<String> = std::env::args().collect();

    match args.as_slice() {
        // If no arguments are passed, run wizard
        [_] => run(),

        // Print usage instructions if the input is "help"
        [_, cmd] if cmd == "help" => print_usage(),

        // Print usage instructions if the input is invalid
        _ => print_usage(),
    }
}

fn print_usage() {
    println!("Usage: quiklang-to-bin");
    println!("The program will walk you through the process of turning your quiklang file into native executables.")
}

fn run() {
    println!("{}", "Checking required dependencies...".bright_black());
    check_rust_and_cargo_versions();

    let file_name: String = Input::new()
        .with_prompt("Enter the Quiklang file name (Include file extension) (.QLBC)")
        .interact_text()
        .expect("Failed to read input");

    let quiklang_name: String = Input::new()
        .with_prompt("Enter the name of executables")
        .interact_text()
        .expect("Failed to read input");

    let targets = vec![
        "x86_64-unknown-linux-gnu",
        "x86_64-apple-darwin",
        "x86_64-pc-windows-msvc",
        "x86_64-pc-windows-gnu",
        "aarch64-unknown-linux-gnu",
        "aarch64-apple-darwin",
        "aarch64-pc-windows-msvc",
        "aarch64-pc-windows-gnu",
        "i686-unknown-linux-gnu",
        "i686-pc-windows-msvc",
        "i686-pc-windows-gnu",
    ];

    // Select targets
    let selected_targets = MultiSelect::new()
        .with_prompt(format!(
            "Select the target Rust platforms. {}",
            "[SPACE] to select. [ENTER] to submit. The next prompt allows input for additional targets.".bright_black()
        ))
        .items(&targets)
        .interact()
        .expect("Failed to select targets");

    let selected_targets: Vec<&str> = selected_targets.iter().map(|&i| targets[i]).collect();

    let custom_targets: Vec<String> = Input::<String>::new()
        .with_prompt(format!(
            "Enter custom target platforms (separated by commas). {}",
            "Example: 'wasm32-unknown-unknown'. Leave blank if none".bright_black()
        ))
        .allow_empty(true)
        .interact_text()
        .expect("Failed to read input")
        .split(',')
        .map(|s| s.trim().to_string())
        .collect();

    let all_targets: Vec<&str> = selected_targets
        .iter()
        .copied()
        .chain(custom_targets.iter().map(|s| s.as_str()))
        .collect();

    check_and_install_targets(&all_targets);

    println!();

    println!("File name: {}", file_name.bold().yellow());
    println!("Executable name: {}", quiklang_name.bold().yellow());
    println!(
        "Selected targets: {}",
        all_targets.join(", ").bold().yellow()
    );

    if all_targets.is_empty() {
        println!("{}", "No targets selected. Aborting operation.".red());
        return;
    }
    compile_quiklang_code(&quiklang_name, &file_name, &all_targets);
}

fn compile_quiklang_code(quiklang_name: &str, file_name: &str, selected_targets: &[&str]) {
    // 1. Create the rust file for compilation.
    let rust_code = r#"
        // AUTO GENERATED BY QUIKLANG-TO-BIN

use quiklang::backend_vm::bytecode::ByteCode;
use quiklang::backend_vm::vm::VM;
use quiklang::errors::VMRuntimeError;

const QBIN_DATA: &[u8] = include_bytes!(concat!(env!("CARGO_MANIFEST_DIR"), "/qbin_file.qbin"));
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let bytecode = ByteCode::decode(QBIN_DATA)?;
    let mut vm = VM::from_bytecode(bytecode);
    match vm.execute() {
        Ok(_) => Ok(()),
        Err(VMRuntimeError::Exit(code)) => std::process::exit(code),
        Err(e) => Err(Box::new(e)),
    }
}
        "#
    .to_string();

    // Write Rust code to a temporary file
    let rust_path = "temp_main.rs";
    fs::write(rust_path, rust_code).expect("Failed to write temporary main.rs.");

    // Write the .qbin data to a temporary file
    let qlbc_data = fs::read(file_name).expect("Failed to read .QLBC file.");
    let qlbc_temp_path = "temp_qlbc_file.qlbc";
    fs::write(qlbc_temp_path, qlbc_data).expect("Failed to write temporary qbin file.");

    // If dir exists, request user to either delete/rename dir to make way for dir, or abort operation
    if fs::metadata(quiklang_name).is_ok() {
        let response: String = Input::new()
            .with_prompt(format!(
                "Directory {} already exists. Do you want to delete it? (y/n)",
                quiklang_name
            ))
            .interact_text()
            .expect("Failed to read input");

        if response.to_lowercase() == "y" {
            fs::remove_dir_all(quiklang_name).expect("Failed to remove existing directory");
        } else {
            println!("Aborting operation.");
            return;
        }
    }

    // 2. Create new rust project
    Command::new("cargo")
        .args(["new", "--bin", quiklang_name])
        .status()
        .expect("Failed to create new project");

    // Replace the main.rs in the new Rust project
    fs::copy(rust_path, format!("{}/src/main.rs", quiklang_name)).expect("Failed to copy main.rs");

    // Copy the temporary qbin file to the new Rust project
    fs::copy(qlbc_temp_path, format!("{}/qbin_file.qbin", quiklang_name))
        .expect("Failed to copy qbin file");

    // 3. Edit Cargo.toml
    let cargo_toml_path = format!("{}/Cargo.toml", quiklang_name);
    let mut cargo_toml = fs::read_to_string(&cargo_toml_path).expect("Failed to read Cargo.toml");
    cargo_toml.push_str("quiklang = { git = \"https://github.com/nulluser0/quiklang\" }\n");
    cargo_toml.push_str("\n[profile.release]");
    cargo_toml.push_str("\nlto = \"fat\"");
    cargo_toml.push_str("\ncodegen-units = 1");
    cargo_toml.push_str("\npanic = \"abort\"");
    cargo_toml.push_str("\nstrip = \"symbols\"");
    fs::write(&cargo_toml_path, cargo_toml).expect("Failed to write Cargo.toml");

    // 4. Build the project for each target
    println!("{}", "Building executables...".yellow().bold());
    let mut build_results: Vec<(String, bool)> = Vec::new(); // Track build results

    for target in selected_targets {
        println!("Building for target: {}", target.yellow());
        let status = Command::new("cargo")
            .args(["build", "--release", "--target", target])
            .current_dir(quiklang_name)
            .status()
            .expect("Failed to build project");

        if status.success() {
            println!("Successfully built for target: {}", target.green());
            build_results.push((target.to_string(), true)); // Track successful build
        } else {
            eprintln!("Failed to build for target: {}", target.red());
            build_results.push((target.to_string(), false)); // Track failed build
        }
    }

    // 5. Print build results
    println!();
    println!("{}", "Build Results:".bold());
    for (target, success) in &build_results {
        let result = if *success {
            "Success".green().bold()
        } else {
            "Failure".red().bold()
        };
        println!("Target: {} - Result: {}", target, result);
    }

    // 6. Move target directory out of the project and delete the project
    #[cfg(not(windows))]
    {
        println!("\n{}", "Moving executables...".yellow().bold());
        for (target, success) in build_results {
            if success {
                let target_dir = format!("{}/target/{}", quiklang_name, target);
                let new_target_dir = format!("target/{}", target);
                fs::create_dir_all(&new_target_dir).expect("Failed to create target directory");
                fs::rename(&target_dir, new_target_dir).expect("Failed to move target directory");
            }
        }
    }

    // 7. Clean up temporary files
    println!("\n{}", "Cleaning up...".yellow().bold());
    fs::remove_file(rust_path).expect("Failed to remove temporary main.rs");
    fs::remove_file(qlbc_temp_path).expect("Failed to remove temporary qbin file");
    #[cfg(not(windows))]
    {
        fs::remove_dir_all(quiklang_name)
            .expect("Failed to remove temporary rust project directory");
    }

    println!("{}", "Done!".green().bold());
    #[cfg(windows)]
    {
        println!(
            "You can find the executables in the current directory at ./{}/target",
            quiklang_name
        );
    }
    #[cfg(not(windows))]
    {
        println!("You can find the executables in the current directory at ./target");
    }
}

fn check_rust_and_cargo_versions() {
    let rustc_version = Command::new("rustc")
        .arg("--version")
        .output()
        .expect("Failed to check rustc version. Do you have it installed?");
    println!(
        "Rustc version: {}",
        String::from_utf8_lossy(&rustc_version.stdout).bright_black()
    );

    let cargo_version = Command::new("cargo")
        .arg("--version")
        .output()
        .expect("Failed to check cargo version. Do you have it installed?");
    println!(
        "Cargo version: {}",
        String::from_utf8_lossy(&cargo_version.stdout).bright_black()
    );
}

fn check_and_install_targets(targets: &[&str]) {
    let installed_targets_output = Command::new("rustup")
        .args(["target", "list", "--installed"])
        .output()
        .expect("Failed to list installed targets");
    let installed_targets = String::from_utf8_lossy(&installed_targets_output.stdout);

    for target in targets {
        if !installed_targets.contains(target) && !target.trim().is_empty() {
            println!(
                "Target {} is not installed. Installing...",
                target.bright_red()
            );
            let status = Command::new("rustup")
                .args(["target", "add", target])
                .status()
                .expect("Failed to install target");
            if status.success() {
                println!("Successfully installed target {}", target.green());
            } else {
                eprintln!("Failed to install target {}", target.red());
            }
        } else {
            println!("Target {} is already installed.", target.green());
        }
    }
}
