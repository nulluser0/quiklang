//! # Parser
//!
//! The parser is responsible for parsing the tokens generated by the lexer into an AST.
//!

pub mod symbol_table;

use quiklang_common::{
    data_structs::{
        ast::{
            expr::{
                block_expr::BlockExpr,
                func_call_expr::FuncCallExpr,
                if_expr::IfExpr,
                literal_expr::{Literal, LiteralExpr},
                Expr,
            },
            package_module::{
                Bin, Const, Enum, EnumField, EnumVariant, Function, Global, Impl, Item, Module,
                ModuleItem, Package, Parameter, Struct, StructField, Trait, TypeAlias,
                Visibility,
            },
            paths::{ASTPath, PathSegment},
            stmt::{Stmt, VarDeclStmt},
            types::{ASTType, ASTTypeKind, PrimitiveType},
        },
        tokens::{Keyword, Operator, Symbol, TokenType},
    },
    errors::{parser::ParserError, CompilerError},
    CompilationReport, FileStore,
};
use quiklang_frontend_lexer::{tokenize, Tokens};
use symbol_table::SymbolTable;

pub struct Parser<'a> {
    file_store: &'a mut FileStore,
    compilation_report: &'a mut CompilationReport,
    symbol_table: SymbolTable,
}

struct EntryFiles {
    lib: Option<usize>,
    main: Option<usize>,
    bins: Vec<usize>,
}

impl<'a> Parser<'a> {
    pub fn new(
        file_store: &'a mut FileStore,
        compilation_report: &'a mut CompilationReport,
    ) -> Self {
        Self {
            file_store,
            compilation_report,
            symbol_table: SymbolTable::new(),
        }
    }

    /// Collects all entry files: lib, main, and binaries.
    fn collect_entry_files(&self) -> Result<EntryFiles, ()> {
        let mut entry_files = EntryFiles {
            lib: None,
            main: None,
            bins: Vec::new(),
        };

        for file in self.file_store.files() {
            let path = std::path::Path::new(&file.name);

            if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                if file_name == "lib.quik" {
                    entry_files.lib = Some(file.id);
                } else if file_name == "main.quik" {
                    entry_files.main = Some(file.id);
                } else if path.starts_with("src/bin") && file_name.ends_with(".quik") {
                    entry_files.bins.push(file.id);
                }
            }
        }

        Ok(entry_files)
    }

    /// Entry point for the parser, which parses the entire package.
    pub fn parse_package(&mut self) -> Result<Package, ()> {
        // Collect entry files
        let entry_files = self.collect_entry_files()?;

        // Use package metadata from FileStore or external source
        let package_metadata = match self.file_store.project_metadata.as_ref() {
            Some(result) => result,
            None => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::NoEntryPoint {
                        suggestion: vec![
                            "Add a Package.toml file to the project directory.".to_string()
                        ],
                    }));
                return Err(());
            }
        };

        // Create the package
        let mut package = Package {
            name: package_metadata.package.name.clone(),
            version: package_metadata.package.version.clone(),
            authors: package_metadata.package.authors.clone(),
            description: package_metadata.package.description.clone(),
            library: None,
            binaries: Vec::new(),
            dependencies: vec![],
        };

        // Parse the library module if it exists
        if let Some(lib_file_id) = entry_files.lib {
            let lib_module = self.parse_module_file(lib_file_id)?;
            package.library = Some(lib_module);
        }

        // Parse the main binary if it exists
        if let Some(main_file_id) = entry_files.main {
            let main_binary = self.parse_binary_file(main_file_id, "main".to_string())?;
            package.binaries.push(main_binary);
        }

        // Parse additional binaries
        for bin_file_id in entry_files.bins {
            let bin_file = self.file_store.get_file(bin_file_id).unwrap();
            let bin_name = std::path::Path::new(&bin_file.name)
                .file_stem()
                .unwrap()
                .to_string_lossy()
                .to_string();
            let binary = self.parse_binary_file(bin_file_id, bin_name)?;
            package.binaries.push(binary);
        }

        // Check for any compilation errors
        if self.compilation_report.has_errors() {
            return Err(());
        }

        Ok(package)
    }

    /// Parses a module file and returns a `Module`.
    fn parse_module_file(&mut self, file_id: usize) -> Result<Module, ()> {
        let file = self.file_store.get_file(file_id).unwrap().clone();
        let mut module = Module {
            name: file.name.split('/').last().unwrap().replace(".quik", ""),
            items: vec![],
            submodules: vec![],
        };

        self.parse_module(file.source.clone(), file_id, &mut module);
        Ok(module)
    }

    /// Parses a binary file and returns a `Binary`.
    fn parse_binary_file(&mut self, file_id: usize, name: String) -> Result<Bin, ()> {
        let module = self.parse_module_file(file_id)?;
        let binary = Bin { name, module };
        Ok(binary)
    }

    /// Parses a module.
    fn parse_module(&mut self, source: String, file_id: usize, module: &mut Module) {
        // Lex the source code
        let mut tokens = tokenize(&source, file_id, &mut self.compilation_report);

        // Parse the tokens
        while tokens.not_eof() {
            let item = self.parse_module_item(&mut tokens);
            if let Some(item) = item {
                module.items.push(item);
            }
        }
    }

    /// Parses a module item.
    fn parse_module_item(&mut self, tokens: &mut Tokens) -> Option<ModuleItem> {
        // Parse visibility
        let visibility = self.parse_visibility(tokens);

        // Parse the rest of the module item
        match &tokens.at().token {
            TokenType::Keyword(Keyword::Fn) => {
                let function = self.parse_module_function(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Function(function),
                })
            }
            TokenType::Keyword(Keyword::Struct) => {
                let structure = self.parse_module_struct(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Struct(structure),
                })
            }
            TokenType::Keyword(Keyword::Enum) => {
                let enumeration = self.parse_module_enum(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Enum(enumeration),
                })
            }
            TokenType::Keyword(Keyword::Type) => {
                let type_alias = self.parse_module_type_alias(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::TypeAlias(type_alias),
                })
            }
            TokenType::Keyword(Keyword::Trait) => {
                let trait_item = self.parse_module_trait(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Trait(trait_item),
                })
            }
            TokenType::Keyword(Keyword::Impl) => {
                let impl_item = self.parse_module_impl(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Impl(impl_item),
                })
            }
            TokenType::Keyword(Keyword::Const) => {
                let const_item = self.parse_module_const(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Const(const_item),
                })
            }
            TokenType::Keyword(Keyword::Global) => {
                let global = self.parse_module_global(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Global(global),
                })
            }
            TokenType::Keyword(Keyword::Mod) => {
                // Handle submodule parsing here if necessary
                // For now, we'll skip this
                tokens.eat(); // Consume 'mod'
                tokens.eat(); // Consume the module name
                None
            }
            _ => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "module item".to_string(),
                        found: tokens.at().token.clone(),
                        span: tokens.at().span,
                        suggestion: vec![
                            "Expected a module item such as a function, struct, enum, etc."
                                .to_string(),
                        ],
                    }));
                None
            }
        }
    }

    /// Parses visibility modifiers.
    fn parse_visibility(&mut self, tokens: &mut Tokens) -> Visibility {
        match tokens.at().token {
            // Pub
            TokenType::Keyword(Keyword::Pub) => {
                tokens.eat();
                // Check for pub(package), pub(super), etc.
                if let TokenType::Symbol(Symbol::LeftParen) = tokens.at().token {
                    tokens.eat();
                    let visibility = match tokens.at().token {
                        // pub(package)
                        TokenType::Keyword(Keyword::Package) => {
                            tokens.eat();
                            Visibility::Package
                        }
                        // pub(super)
                        TokenType::Keyword(Keyword::Super) => {
                            tokens.eat();
                            Visibility::Super
                        }
                        // Error
                        _ => {
                            self.compilation_report
                                .add_error(CompilerError::ParserError(
                                    ParserError::UnexpectedToken {
                                        expected: "package or super".to_string(),
                                        found: tokens.at().token.clone(),
                                        span: tokens.at().span,
                                        suggestion: vec![
                                            "Expected 'package' or 'super' after 'pub('."
                                                .to_string(),
                                        ],
                                    },
                                ));
                            Visibility::Private
                        }
                    };
                    tokens.expect(
                        TokenType::Symbol(Symbol::RightParen),
                        &mut self.compilation_report,
                    );
                    visibility
                } else {
                    // pub
                    Visibility::Public
                }
            }
            // private
            _ => Visibility::Private,
        }
    }

    /// Parses a function.
    fn parse_module_function(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Function> {
        // Consume 'fn' token
        tokens.eat();

        // Parse function identifier
        let ident = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "identifier".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected an identifier after 'fn'.".to_string()],
                    }));
                return None;
            }
        };

        // Parse function parameters
        let params = self.parse_module_function_params(tokens)?;

        // Parse function return type
        let return_ty = if tokens.at().token == TokenType::Symbol(Symbol::Arrow) {
            tokens.eat();
            self.parse_type_declaration(tokens)?
        } else {
            ASTType {
                kind: ASTTypeKind::Primitive(PrimitiveType::Void),
            }
        };

        // Parse function body
        let body = self.parse_block(tokens)?;

        Some(Function {
            name: ident,
            parameters: params,
            return_type: return_ty.kind,
            body,
        })
    }

    /// Parses function parameters.
    fn parse_module_function_params(&mut self, tokens: &mut Tokens) -> Option<Vec<Parameter>> {
        // Consume left parenthesis
        tokens.expect(
            TokenType::Symbol(Symbol::LeftParen),
            &mut self.compilation_report,
        );

        let mut params = Vec::new();

        // Parse parameters
        while tokens.at().token != TokenType::Symbol(Symbol::RightParen) && tokens.not_eof() {
            // Parse parameter
            let param = self.parse_module_function_param(tokens)?;
            params.push(param);

            // Check for comma
            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            } else {
                break;
            }
        }

        // Consume right parenthesis
        tokens.expect(
            TokenType::Symbol(Symbol::RightParen),
            &mut self.compilation_report,
        );

        Some(params)
    }

    /// Parses a single function parameter.
    fn parse_module_function_param(&mut self, tokens: &mut Tokens) -> Option<Parameter> {
        // Parse parameter identifier
        let ident = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "identifier".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected an identifier in parameter list.".to_string()],
                    }));
                return None;
            }
        };

        // Expect colon ':'
        tokens.expect(
            TokenType::Symbol(Symbol::Colon),
            &mut self.compilation_report,
        );

        // Parse parameter type
        let ty = self.parse_type_declaration(tokens)?;

        // Optional default value
        let default_value = if tokens.at().token == TokenType::Operator(Operator::Assign) {
            tokens.eat(); // Consume '='
            Some(self.parse_expression(tokens)?)
        } else {
            None
        };

        Some(Parameter {
            name: ident,
            ty: ty.kind,
            default_value,
        })
    }

    /// Parses a type declaration.
    fn parse_type_declaration(&mut self, tokens: &mut Tokens) -> Option<ASTType> {
        let ty = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "type identifier".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a type identifier.".to_string()],
                    }));
                return None;
            }
        };

        let mut path_segments = vec![PathSegment {
            name: ty,
            args: vec![],
            span: tokens.at().span,
        }];

        // Handle paths with '::'
        while tokens.at().token == TokenType::Symbol(Symbol::DoubleColon) {
            tokens.eat(); // Consume '::'
            match &tokens.eat().token {
                TokenType::Identifier(ident) => {
                    path_segments.push(PathSegment {
                        name: ident.clone(),
                        args: vec![],
                        span: tokens.at().span,
                    });
                }
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "identifier".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected an identifier after '::'.".to_string()],
                        }));
                    return None;
                }
            }
        }

        Some(ASTType {
            kind: ASTTypeKind::Path(ASTPath {
                segments: path_segments,
                span: tokens.at().span,
            }),
        })
    }

    /// Parses a block expression.
    fn parse_block(&mut self, tokens: &mut Tokens) -> Option<BlockExpr> {
        tokens.expect(
            TokenType::Symbol(Symbol::LeftBrace),
            &mut self.compilation_report,
        );

        let mut stmts = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightBrace) && tokens.not_eof() {
            let stmt = self.parse_statement(tokens)?;
            stmts.push(stmt);
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightBrace),
            &mut self.compilation_report,
        );

        Some(BlockExpr {
            stmts,
            span: tokens.at().span,
        })
    }

    /// Parses a statement.
    fn parse_statement(&mut self, tokens: &mut Tokens) -> Option<Stmt> {
        match &tokens.at().token {
            TokenType::Keyword(Keyword::Let) => {
                let declare = self.parse_var_decl_statement(tokens);
                if let Some(declare) = declare {
                    Some(Stmt::VarDecl(declare))
                } else {
                    None
                }
            },
            _ => {
                let expr = self.parse_expression(tokens);
                if let Some(expr) = expr {
                    Some(Stmt::Expr(expr))
                } else {
                    None
                }
            },
        }
    }

    /// Parses a variable declaration statement.
    fn parse_var_decl_statement(&mut self, tokens: &mut Tokens) -> Option<VarDeclStmt> {
        tokens.eat(); // Consume 'let'

        // Parse mutability
        let mutable = if tokens.at().token == TokenType::Keyword(Keyword::Mut) {
            tokens.eat(); // Consume 'mut'
            true
        } else {
            false
        };

        // Parse variable name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "variable name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a variable name.".to_string()],
                    }));
                return None;
            }
        };

        // Parse variable type
        let ty = if tokens.at().token == TokenType::Symbol(Symbol::Colon) {
            tokens.eat(); // Consume ':'
            self.parse_type_declaration(tokens)?
        } else {
            ASTType {
                kind: ASTTypeKind::Infer,
            }
        };

        // Parse variable value if present
        let value = if tokens.at().token == TokenType::Operator(Operator::Assign) {
            tokens.eat(); // Consume '='
            self.parse_expression(tokens)
        } else {
            None
        };

        Some(VarDeclStmt { name, mutable, ty: ty.kind, value, span: tokens.at().span })
    }

    /// Parses an expression.
    fn parse_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        self.parse_primary_expression(tokens)
    }

    /// Parses a primary expression.
    fn parse_primary_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        // Use a smaller scope for the mutable borrow
        let token = tokens.eat();
        let span = token.span.clone();
        match &token.token {
            TokenType::IntegerLiteral(value) => Some(Expr::Literal(LiteralExpr {
                value: Literal::Integer(*value),
                span,
            })),
            TokenType::FloatLiteral(value) => Some(Expr::Literal(LiteralExpr {
                value: Literal::Float(*value),
                span,
            })),
            TokenType::StringLiteral(value) => Some(Expr::Literal(LiteralExpr {
                value: Literal::String(value.to_string()),
                span,
            })),
            TokenType::Identifier(name) => {
                // Clone the name to end the borrow of `token`
                let name_clone = name.clone();
                // The mutable borrow from `tokens.eat()` ends here because `token` is no longer used

                // Now we can safely peek without borrow conflicts
                if let Some(next_token) = tokens.peek() {
                    if next_token.token == TokenType::Symbol(Symbol::LeftParen) {
                        tokens.eat(); // Consume the '('

                        // Function call
                        let args = self.parse_call_arguments(tokens)?;
                        return Some(Expr::FuncCall(FuncCallExpr {
                            func: Box::new(Expr::Literal(LiteralExpr {
                                value: Literal::String(name_clone),
                                span,
                            })),
                            args,
                            span,
                        }));
                    }
                }

                // Variable reference (for now, treat as literal)
                Some(Expr::Literal(LiteralExpr {
                    value: Literal::String(name_clone),
                    span,
                }))
            }
            TokenType::Symbol(Symbol::LeftParen) => {
                // Parenthesized expression
                let expr = self.parse_expression(tokens)?;
                tokens.expect(
                    TokenType::Symbol(Symbol::RightParen),
                    &mut self.compilation_report,
                );
                Some(expr)
            }
            TokenType::Keyword(Keyword::If) => self.parse_if_expression(tokens),
            _ => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "expression".to_string(),
                        found: token.token.clone(),
                        span: token.span,
                        suggestion: vec!["Expected an expression.".to_string()],
                    }));
                None
            }
        }
    }

    /// Parses function call arguments.
    fn parse_call_arguments(&mut self, tokens: &mut Tokens) -> Option<Vec<Expr>> {
        tokens.expect(
            TokenType::Symbol(Symbol::LeftParen),
            &mut self.compilation_report,
        );

        let mut args = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightParen) && tokens.not_eof() {
            let arg = self.parse_expression(tokens)?;
            args.push(arg);

            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            } else {
                break;
            }
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightParen),
            &mut self.compilation_report,
        );

        Some(args)
    }

    /// Parses an if expression.
    fn parse_if_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let if_span = tokens.at().span;
        tokens.eat(); // Consume 'if'

        // Parse condition
        let condition = self.parse_expression(tokens)?;

        // Parse then block
        let then_block = self.parse_block(tokens)?;

        // Optional else block
        let else_block = if tokens.at().token == TokenType::Keyword(Keyword::Else) {
            tokens.eat(); // Consume 'else'
            if tokens.at().token == TokenType::Keyword(Keyword::If) {
                // Else if
                Some(Box::new(self.parse_if_expression(tokens)?))
            } else {
                // Else block
                Some(Box::new(Expr::Block(self.parse_block(tokens)?)))
            }
        } else {
            None
        };

        Some(Expr::If(IfExpr {
            cond: Box::new(condition),
            then_block: Box::new(Expr::Block(then_block)),
            else_block,
            span: if_span,
        }))
    }

    fn parse_module_struct(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Struct> {
        // Consume 'struct'
        tokens.eat();

        // Parse struct name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "struct name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a struct name.".to_string()],
                    }));
                return None;
            }
        };

        // Parse struct fields
        tokens.expect(
            TokenType::Symbol(Symbol::LeftBrace),
            &mut self.compilation_report,
        );

        let mut fields = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightBrace) && tokens.not_eof() {
            // Parse field visibility
            let field_visibility = self.parse_visibility(tokens);

            // Parse field name
            let field_name = match &tokens.eat().token {
                TokenType::Identifier(ident) => ident.clone(),
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "field name".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected a field name.".to_string()],
                        }));
                    return None;
                }
            };

            tokens.expect(
                TokenType::Symbol(Symbol::Colon),
                &mut self.compilation_report,
            );

            // Parse field type
            let field_type = self.parse_type_declaration(tokens)?;

            // Check for comma
            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            }

            fields.push(StructField {
                name: field_name,
                ty: field_type.kind,
                visibility: field_visibility,
            });
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightBrace),
            &mut self.compilation_report,
        );

        Some(Struct {
            name,
            fields,
            generics: vec![], // Generics parsing not implemented here
        })
    }

    fn parse_module_enum(&mut self, _visibility: Visibility, tokens: &mut Tokens) -> Option<Enum> {
        tokens.eat(); // Consume 'enum'

        // Parse enum name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "enum name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected an enum name.".to_string()],
                    }));
                return None;
            }
        };

        // Parse enum variants
        tokens.expect(
            TokenType::Symbol(Symbol::LeftBrace),
            &mut self.compilation_report,
        );

        let mut variants = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightBrace) && tokens.not_eof() {
            // Parse variant name
            let variant_name = match &tokens.eat().token {
                TokenType::Identifier(ident) => ident.clone(),
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "variant name".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected a variant name.".to_string()],
                        }));
                    return None;
                }
            };

            // For simplicity, we won't parse variant fields here
            // Check for comma
            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            }

            variants.push(EnumVariant {
                name: variant_name,
                fields: EnumField::None,
            });
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightBrace),
            &mut self.compilation_report,
        );

        Some(Enum {
            name,
            variants,
            generics: vec![], // Generics parsing not implemented here
        })
    }

    fn parse_module_type_alias(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<TypeAlias> {
        tokens.eat(); // Consume 'type'

        // Parse type alias name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "type alias name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a type alias name.".to_string()],
                    }));
                return None;
            }
        };

        tokens.expect(
            TokenType::Operator(Operator::Assign),
            &mut self.compilation_report,
        );

        // Parse the aliased type
        let ty = self.parse_type_declaration(tokens)?;

        tokens.expect(
            TokenType::Symbol(Symbol::Semicolon),
            &mut self.compilation_report,
        );

        Some(TypeAlias {
            name,
            ty: ty.kind,
            generics: vec![],
        })
    }

    fn parse_module_trait(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Trait> {
        // For brevity, we'll not implement trait parsing here
        tokens.eat(); // Consume 'trait'
        tokens.eat(); // Consume trait name
                      // Skip the trait body
        None
    }

    fn parse_module_impl(&mut self, _visibility: Visibility, tokens: &mut Tokens) -> Option<Impl> {
        // For brevity, we'll not implement impl parsing here
        tokens.eat(); // Consume 'impl'
                      // Skip the impl body
        None
    }

    fn parse_module_const(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Const> {
        tokens.eat(); // Consume 'const'

        // Parse const name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "const name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a constant name.".to_string()],
                    }));
                return None;
            }
        };

        tokens.expect(
            TokenType::Symbol(Symbol::Colon),
            &mut self.compilation_report,
        );

        // Parse const type
        let ty = self.parse_type_declaration(tokens)?;

        tokens.expect(
            TokenType::Operator(Operator::Assign),
            &mut self.compilation_report,
        );

        // Parse const value
        let value = self.parse_expression(tokens)?;

        tokens.expect(
            TokenType::Symbol(Symbol::Semicolon),
            &mut self.compilation_report,
        );

        Some(Const {
            name,
            visibility: Visibility::Private, // Assuming private for now
            ty: ty.kind,
            value,
        })
    }

    fn parse_module_global(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Global> {
        // For brevity, we'll not implement global variable parsing here
        tokens.eat(); // Consume 'global'
        None
    }

    fn parse_module_mod(&mut self, _visibility: Visibility, _tokens: &mut Tokens) {
        todo!()
    }
}
