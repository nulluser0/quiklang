//! # Parser
//!
//! The parser is responsible for parsing the tokens generated by the lexer into an AST.
//!

use std::collections::HashMap;

use quiklang_common::{
    data_structs::{
        ast::{
            expr::{
                array_expr::{ArrayExpr, ListArrayExpr},
                array_index_expr::ArrayIndexExpr,
                block_expr::BlockExpr,
                control_expr::{BreakExpr, ReturnExpr},
                field_access_expr::FieldAccessExpr,
                func_call_expr::FuncCallExpr,
                if_expr::IfExpr,
                literal_expr::{Literal, LiteralExpr},
                method_call_expr::MethodCallExpr,
                operator_expr::{
                    AssignmentOperatorExpr, BinaryOperator, BinaryOperatorExpr, BooleanOperator,
                    BooleanOperatorExpr, ComparisonOperator, ComparisonOperatorExpr, OperatorExpr,
                    PropagatorOperator, PropagatorOperatorExpr, TypeCastOperatorExpr,
                    UnaryOperator, UnaryOperatorExpr,
                },
                tuple_index_expr::TupleIndexExpr,
                Expr,
            },
            package_module::{
                Bin, Const, Enum, EnumField, EnumVariant, Function, Global, Impl, Item, Module,
                ModuleItem, Package, Parameter, Struct, StructField, Trait, TypeAlias, Use,
                Visibility,
            },
            paths::{
                ASTExprPath, ASTSimplePath, ASTTypePath, ExprPathSegment, SimplePathSegment,
                TypePathSegment,
            },
            stmt::{Stmt, VarDeclStmt},
            types::{ASTType, ASTTypeKind, PrimitiveType},
        },
        tokens::{Keyword, Operator, Symbol, TokenType},
    },
    errors::{parser::ParserError, CompilerError},
    CompilationReport, FileStore,
};
use quiklang_frontend_lexer::{tokenize, Tokens};

pub struct Parser<'a> {
    file_store: &'a mut FileStore,
    compilation_report: &'a mut CompilationReport,
    parsed_modules: HashMap<usize, Module>,
}

struct EntryFiles {
    lib: Option<usize>,
    main: Option<usize>,
    bins: Vec<usize>,
}

impl<'a> Parser<'a> {
    pub fn new(
        file_store: &'a mut FileStore,
        compilation_report: &'a mut CompilationReport,
    ) -> Self {
        Self {
            file_store,
            compilation_report,
            parsed_modules: HashMap::new(),
        }
    }

    /// Collects all entry files: lib, main, and binaries.
    fn collect_entry_files(&self) -> Option<EntryFiles> {
        let mut entry_files = EntryFiles {
            lib: None,
            main: None,
            bins: Vec::new(),
        };

        for file in self.file_store.files() {
            let path = std::path::Path::new(&file.name);

            if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                if file_name == "lib.quik" {
                    entry_files.lib = Some(file.id);
                } else if file_name == "main.quik" {
                    entry_files.main = Some(file.id);
                } else if path.starts_with("src/bin") && file_name.ends_with(".quik") {
                    entry_files.bins.push(file.id);
                }
            }
        }

        Some(entry_files)
    }

    /// Entry point for the parser, which parses the entire package.
    pub fn parse_package(&mut self) -> Option<Package> {
        // Collect entry files
        let entry_files = self.collect_entry_files()?;

        // Use package metadata from FileStore or external source
        let package_metadata = match self.file_store.project_metadata.as_ref() {
            Some(result) => result,
            None => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::NoEntryPoint {
                        suggestion: vec![
                            "Add a Package.toml file to the project directory.".to_string()
                        ],
                    }));
                return None;
            }
        };

        // Create the package
        let mut package = Package {
            name: package_metadata.package.name.clone(),
            version: package_metadata.package.version.clone(),
            authors: package_metadata.package.authors.clone(),
            description: package_metadata.package.description.clone(),
            library: None,
            binaries: Vec::new(),
            dependencies: vec![],
        };

        // Parse the library module if it exists
        if let Some(lib_file_id) = entry_files.lib {
            let lib_module = self.parse_module_file(lib_file_id)?;
            package.library = Some(lib_module);
        }

        // Parse the main binary if it exists
        if let Some(main_file_id) = entry_files.main {
            let main_binary = self.parse_binary_file(main_file_id, "main".to_string())?;
            package.binaries.push(main_binary);
        }

        // Parse additional binaries
        for bin_file_id in entry_files.bins {
            let bin_file = self.file_store.get_file(bin_file_id).unwrap();
            let bin_name = std::path::Path::new(&bin_file.name)
                .file_stem()
                .unwrap()
                .to_string_lossy()
                .to_string();
            let binary = self.parse_binary_file(bin_file_id, bin_name)?;
            package.binaries.push(binary);
        }

        // Check for any compilation errors
        if self.compilation_report.has_errors() {
            return None;
        }

        Some(package)
    }

    /// Parses a module file and returns a `Module`.
    fn parse_module_file(&mut self, file_id: usize) -> Option<Module> {
        if let Some(module) = self.parsed_modules.get(&file_id) {
            return Some(module.clone());
        }

        let file = self.file_store.get_file(file_id).unwrap().clone();
        let mut module = Module {
            name: file.name.split('/').last().unwrap().replace(".quik", ""),
            items: vec![],
            submodules: vec![],
        };

        self.parse_module(file.source.clone(), file_id, &mut module);

        // Store the parsed module
        self.parsed_modules.insert(file_id, module.clone());

        Some(module)
    }

    /// Parses a binary file and returns a `Binary`.
    fn parse_binary_file(&mut self, file_id: usize, name: String) -> Option<Bin> {
        let module = self.parse_module_file(file_id)?;
        let binary = Bin { name, module };
        Some(binary)
    }

    /// Parses a module from source code, like root module or 'mod foo;'
    fn parse_module(&mut self, source: String, file_id: usize, module: &mut Module) {
        // Lex the source code
        let mut tokens = tokenize(&source, file_id, self.compilation_report);

        // Parse the tokens
        while tokens.not_eof() {
            let item = self.parse_module_item(&mut tokens, module, file_id);
            if let Some(item) = item {
                module.items.push(item);
            }
        }
    }

    /// Parses a module item.
    fn parse_module_item(
        &mut self,
        tokens: &mut Tokens,
        module: &mut Module,
        current_file_id: usize,
    ) -> Option<ModuleItem> {
        // Parse visibility
        let visibility = self.parse_visibility(tokens);

        // Parse the rest of the module item
        match &tokens.at().token {
            TokenType::Keyword(Keyword::Fn) => {
                let function = self.parse_module_function(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Function(function),
                })
            }
            TokenType::Keyword(Keyword::Struct) => {
                let structure = self.parse_module_struct(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Struct(structure),
                })
            }
            TokenType::Keyword(Keyword::Enum) => {
                let enumeration = self.parse_module_enum(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Enum(enumeration),
                })
            }
            TokenType::Keyword(Keyword::Type) => {
                let type_alias = self.parse_module_type_alias(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::TypeAlias(type_alias),
                })
            }
            TokenType::Keyword(Keyword::Trait) => {
                let trait_item = self.parse_module_trait(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Trait(trait_item),
                })
            }
            TokenType::Keyword(Keyword::Impl) => {
                let impl_item = self.parse_module_impl(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Impl(impl_item),
                })
            }
            TokenType::Keyword(Keyword::Const) => {
                let const_item = self.parse_module_const(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Const(const_item),
                })
            }
            TokenType::Keyword(Keyword::Global) => {
                let global = self.parse_module_global(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Global(global),
                })
            }
            TokenType::Keyword(Keyword::Mod) => {
                let submodule = self.parse_module_mod(visibility, tokens, current_file_id)?;

                module.submodules.push(submodule);

                None
            }
            TokenType::Keyword(Keyword::Use) => {
                let use_item = self.parse_module_use(visibility, tokens)?;
                Some(ModuleItem {
                    visibility,
                    item: Item::Use(use_item),
                })
            }
            _ => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "module item".to_string(),
                        found: tokens.at().token.clone(),
                        span: tokens.at().span,
                        suggestion: vec![
                            "Expected a module item such as a function, struct, enum, etc."
                                .to_string(),
                        ],
                    }));
                None
            }
        }
    }

    /// Parses visibility modifiers.
    fn parse_visibility(&mut self, tokens: &mut Tokens) -> Visibility {
        match tokens.at().token {
            // Pub
            TokenType::Keyword(Keyword::Pub) => {
                tokens.eat();
                // Check for pub(package), pub(super), etc.
                if let TokenType::Symbol(Symbol::LeftParen) = tokens.at().token {
                    tokens.eat();
                    let visibility = match tokens.at().token {
                        // pub(package)
                        TokenType::Keyword(Keyword::Package) => {
                            tokens.eat();
                            Visibility::Package
                        }
                        // pub(super)
                        TokenType::Keyword(Keyword::Super) => {
                            tokens.eat();
                            Visibility::Super
                        }
                        // Error
                        _ => {
                            self.compilation_report
                                .add_error(CompilerError::ParserError(
                                    ParserError::UnexpectedToken {
                                        expected: "package or super".to_string(),
                                        found: tokens.at().token.clone(),
                                        span: tokens.at().span,
                                        suggestion: vec![
                                            "Expected 'package' or 'super' after 'pub('."
                                                .to_string(),
                                        ],
                                    },
                                ));
                            Visibility::Private
                        }
                    };
                    tokens.expect(
                        TokenType::Symbol(Symbol::RightParen),
                        self.compilation_report,
                    );
                    visibility
                } else {
                    // pub
                    Visibility::Public
                }
            }
            // private
            _ => Visibility::Private,
        }
    }

    /// Parses a function.
    fn parse_module_function(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Function> {
        // Consume 'fn' token
        tokens.eat();

        // Parse function identifier
        let ident = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "identifier".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected an identifier after 'fn'.".to_string()],
                    }));
                return None;
            }
        };

        // Parse function parameters
        let params = self.parse_module_function_params(tokens)?;

        // Parse function return type
        let return_ty = if tokens.at().token == TokenType::Symbol(Symbol::Arrow) {
            tokens.eat();
            self.parse_type_declaration(tokens)?
        } else {
            ASTType {
                kind: ASTTypeKind::Primitive(PrimitiveType::Void),
            }
        };

        // Parse function body
        let body = self.parse_block(tokens)?;

        Some(Function {
            name: ident,
            parameters: params,
            return_type: return_ty.kind,
            body,
        })
    }

    /// Parses function parameters.
    fn parse_module_function_params(&mut self, tokens: &mut Tokens) -> Option<Vec<Parameter>> {
        // Consume left parenthesis
        tokens.expect(
            TokenType::Symbol(Symbol::LeftParen),
            self.compilation_report,
        );

        let mut params = Vec::new();

        // Parse parameters
        while tokens.at().token != TokenType::Symbol(Symbol::RightParen) && tokens.not_eof() {
            // Parse parameter
            let param = self.parse_module_function_param(tokens)?;
            params.push(param);

            // Check for comma
            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            } else {
                break;
            }
        }

        // Consume right parenthesis
        tokens.expect(
            TokenType::Symbol(Symbol::RightParen),
            self.compilation_report,
        );

        Some(params)
    }

    /// Parses a single function parameter.
    fn parse_module_function_param(&mut self, tokens: &mut Tokens) -> Option<Parameter> {
        // Parse parameter identifier
        let ident = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "identifier".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected an identifier in parameter list.".to_string()],
                    }));
                return None;
            }
        };

        // Expect colon ':'
        tokens.expect(TokenType::Symbol(Symbol::Colon), self.compilation_report);

        // Parse parameter type
        let ty = self.parse_type_declaration(tokens)?;

        // Optional default value
        let default_value = if tokens.at().token == TokenType::Operator(Operator::Assign) {
            tokens.eat(); // Consume '='
            Some(self.parse_expression(tokens)?)
        } else {
            None
        };

        Some(Parameter {
            name: ident,
            ty: ty.kind,
            default_value,
        })
    }

    /// Parses a type declaration.
    /// Also contains its own Type Path parsing logic, since Type Paths are only used in type declarations.
    fn parse_type_declaration(&mut self, tokens: &mut Tokens) -> Option<ASTType> {
        let ty = match &tokens.eat().token {
            // Identifier
            TokenType::Identifier(ident) => ident.clone(),
            TokenType::Keyword(Keyword::Bool) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Bool),
                })
            }
            // Primitive types
            TokenType::Keyword(Keyword::Char) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Char),
                })
            }
            TokenType::Keyword(Keyword::Integer) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Integer),
                })
            }
            TokenType::Keyword(Keyword::Float) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Float),
                })
            }
            TokenType::Keyword(Keyword::String) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::String),
                })
            }
            TokenType::Keyword(Keyword::Void) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Void),
                })
            }
            TokenType::Keyword(Keyword::Null) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Null),
                })
            }
            // List Array Type
            TokenType::Keyword(Keyword::List) => {
                // Handle list type differently due to different syntax
                tokens.expect(
                    TokenType::Symbol(Symbol::LeftBracket),
                    self.compilation_report,
                );
                let ty = self.parse_type_declaration(tokens)?;
                tokens.expect(
                    TokenType::Symbol(Symbol::RightBracket),
                    self.compilation_report,
                );
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::ListArray(Box::new(ty))),
                });
            }
            // Array Type
            TokenType::Symbol(Symbol::LeftBracket) => {
                let ty = self.parse_type_declaration(tokens)?;
                tokens.expect(
                    TokenType::Symbol(Symbol::Semicolon),
                    self.compilation_report,
                );
                let size = match &tokens.eat().token {
                    TokenType::IntegerLiteral(size) => *size,
                    token => {
                        self.compilation_report
                            .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                                expected: "integer".to_string(),
                                found: token.clone(),
                                span: tokens.at().span,
                                suggestion: vec![
                                    "Expected an integer after ';' to denote array size."
                                        .to_string(),
                                ],
                            }));
                        return None;
                    }
                };
                tokens.expect(
                    TokenType::Symbol(Symbol::RightBracket),
                    self.compilation_report,
                );
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Array(Box::new(ty), size as usize)),
                });
            }
            TokenType::Operator(Operator::LogicalNot) => {
                return Some(ASTType {
                    kind: ASTTypeKind::Primitive(PrimitiveType::Never),
                })
            }
            // Unexpected token
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "type identifier".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a type identifier.".to_string()],
                    }));
                return None;
            }
        };

        let mut path_segments = Vec::new();

        // Parse arguments if present 'T<U>'
        if tokens.at().token == TokenType::Operator(Operator::LessThan) {
            tokens.eat(); // Consume '<'
            let mut args = Vec::new();
            while tokens.at().token != TokenType::Operator(Operator::GreaterThan) {
                let arg = self.parse_type_declaration(tokens)?;
                args.push(arg);
                if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                    tokens.eat(); // Consume ','
                }
            }
            tokens.expect(
                TokenType::Operator(Operator::GreaterThan),
                self.compilation_report,
            );
            path_segments.push(TypePathSegment {
                name: ty,
                args,
                span: tokens.at().span,
            });
        } else {
            path_segments.push(TypePathSegment {
                name: ty,
                args: vec![],
                span: tokens.at().span,
            });
        }

        // Handle paths with '::'
        while tokens.at().token == TokenType::Symbol(Symbol::DoubleColon) {
            tokens.eat(); // Consume '::'
            match &tokens.eat().token {
                TokenType::Identifier(ident) => {
                    let ident_clone = ident.clone();
                    // Mutable borrow from tokens.eat() ends here

                    // Parse arguments if present 'T<U>'
                    if tokens.at().token == TokenType::Operator(Operator::LessThan) {
                        tokens.eat(); // Consume '<'
                        let mut args = Vec::new();
                        while tokens.at().token != TokenType::Operator(Operator::GreaterThan) {
                            let arg = self.parse_type_declaration(tokens)?;
                            args.push(arg);
                            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                                tokens.eat(); // Consume ','
                            }
                        }
                        tokens.expect(
                            TokenType::Operator(Operator::GreaterThan),
                            self.compilation_report,
                        );
                        path_segments.push(TypePathSegment {
                            name: ident_clone,
                            args,
                            span: tokens.at().span,
                        });
                    } else {
                        path_segments.push(TypePathSegment {
                            name: ident_clone,
                            args: vec![],
                            span: tokens.at().span,
                        });
                    }
                }
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "identifier".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected an identifier after '::'.".to_string()],
                        }));
                    return None;
                }
            }
        }

        Some(ASTType {
            kind: ASTTypeKind::Path(ASTTypePath {
                segments: path_segments,
                span: tokens.at().span,
            }),
        })
    }

    /// Parse a path.
    /// This will be useful in use items. Example: `use std::io::Read;`
    fn parse_simple_path(&mut self, tokens: &mut Tokens) -> Option<ASTSimplePath> {
        let mut path_segments = Vec::new();

        // Parse the first path segment
        let token = tokens.eat();
        let ident = match &token.token {
            TokenType::Identifier(ident) => ident.clone(),
            token_type => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "identifier".to_string(),
                        found: token_type.clone(),
                        span: token.span,
                        suggestion: vec!["Expected an identifier in path.".to_string()],
                    }));
                return None;
            }
        };
        // Mutable borrow from tokens.eat() ends here

        // No arguments allowed in simple paths
        path_segments.push(SimplePathSegment {
            name: ident,
            span: token.span,
        });

        // Handle paths with '::'
        while tokens.at().token == TokenType::Symbol(Symbol::DoubleColon) {
            tokens.eat(); // Consume '::'

            let token = tokens.eat();
            match &token.token {
                TokenType::Identifier(ident) => {
                    let ident_clone = ident.clone();
                    // Mutable borrow from tokens.eat() ends here

                    // No arguments allowed in simple paths
                    path_segments.push(SimplePathSegment {
                        name: ident_clone,
                        span: tokens.at().span,
                    });
                }
                token_type => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "identifier".to_string(),
                            found: token_type.clone(),
                            span: token.span,
                            suggestion: vec!["Expected an identifier after '::'.".to_string()],
                        }));
                    return None;
                }
            }
        }

        Some(ASTSimplePath {
            segments: path_segments,
            span: tokens.at().span,
        })
    }

    /// Parses a block expression.
    fn parse_block(&mut self, tokens: &mut Tokens) -> Option<BlockExpr> {
        tokens.expect(
            TokenType::Symbol(Symbol::LeftBrace),
            self.compilation_report,
        );

        let mut stmts = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightBrace) && tokens.not_eof() {
            let stmt = self.parse_statement(tokens)?;
            stmts.push(stmt);
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightBrace),
            self.compilation_report,
        );

        Some(BlockExpr {
            stmts,
            span: tokens.at().span,
        })
    }

    /// Parses a statement.
    fn parse_statement(&mut self, tokens: &mut Tokens) -> Option<Stmt> {
        match &tokens.at().token {
            TokenType::Keyword(Keyword::Let) => {
                let declare = self.parse_var_decl_statement(tokens);
                declare.map(Stmt::VarDecl)
            }
            _ => {
                let expr = self.parse_expression(tokens);
                expr.map(Stmt::Expr)
            }
        }
    }

    /// Parses a variable declaration statement.
    fn parse_var_decl_statement(&mut self, tokens: &mut Tokens) -> Option<VarDeclStmt> {
        tokens.eat(); // Consume 'let'

        // Parse mutability
        let mutable = if tokens.at().token == TokenType::Keyword(Keyword::Mut) {
            tokens.eat(); // Consume 'mut'
            true
        } else {
            false
        };

        // Parse variable name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "variable name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a variable name.".to_string()],
                    }));
                return None;
            }
        };

        // Parse variable type
        let ty = if tokens.at().token == TokenType::Symbol(Symbol::Colon) {
            tokens.eat(); // Consume ':'
            self.parse_type_declaration(tokens)?
        } else {
            ASTType {
                kind: ASTTypeKind::Infer,
            }
        };

        // Parse variable value if present
        let value = if tokens.at().token == TokenType::Operator(Operator::Assign) {
            tokens.eat(); // Consume '='
            self.parse_expression(tokens)
        } else {
            None
        };

        Some(VarDeclStmt {
            name,
            mutable,
            ty: ty.kind,
            value,
            span: tokens.at().span,
        })
    }

    /// Parses an expression. This is the top-level expression parsing function.
    fn parse_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        self.parse_return_or_break_expression(tokens)
    }

    /// Parses a return or break expression. 'return', 'break'
    fn parse_return_or_break_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        if tokens.at().token == TokenType::Keyword(Keyword::Return) {
            tokens.eat(); // Consume 'return'

            // Parse return value
            let expr = if tokens.at().token != TokenType::Symbol(Symbol::Semicolon) {
                self.parse_expression(tokens)
            } else {
                None
            };

            Some(Expr::Return(ReturnExpr {
                value: expr.map(Box::new),
                span: tokens.at().span,
            }))
        } else if tokens.at().token == TokenType::Keyword(Keyword::Break) {
            tokens.eat(); // Consume 'break'

            // Parse break value
            let expr = if tokens.at().token != TokenType::Symbol(Symbol::Semicolon) {
                self.parse_expression(tokens)
            } else {
                None
            };

            Some(Expr::Break(BreakExpr {
                value: expr.map(Box::new),
                span: tokens.at().span,
            }))
        } else {
            self.parse_assignment_expression(tokens)
        }
    }

    /// Parses an assignment expression. '='
    fn parse_assignment_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let lhs = self.parse_logical_or_expression(tokens)?;

        if tokens.at().token == TokenType::Operator(Operator::Assign) {
            tokens.eat(); // Consume '='

            let rhs = self.parse_assignment_expression(tokens)?;

            Some(Expr::Operator(OperatorExpr::Assignment(
                AssignmentOperatorExpr {
                    lhs: Box::new(lhs),
                    rhs: Box::new(rhs),
                    span: tokens.at().span,
                },
            )))
        } else {
            Some(lhs)
        }
    }

    /// Parses a logical OR expression. '||'
    fn parse_logical_or_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.parse_logical_and_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::Or) {
            tokens.eat();
            let rhs = self.parse_logical_and_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Boolean(BooleanOperatorExpr {
                lhs: Box::new(lhs),
                op: BooleanOperator::Or,
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a logical AND expression. '&&'
    fn parse_logical_and_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.parse_equality_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::And) {
            tokens.eat();
            let rhs = self.parse_equality_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Boolean(BooleanOperatorExpr {
                lhs: Box::new(lhs),
                op: BooleanOperator::And,
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses an equality expression. '==', '!='
    fn parse_equality_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.parse_relational_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::Equal)
            || tokens.at().token == TokenType::Operator(Operator::NotEqual)
        {
            let op = tokens.eat().token.clone();
            let rhs = self.parse_relational_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Comparison(ComparisonOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::Equal) => ComparisonOperator::Equal,
                    TokenType::Operator(Operator::NotEqual) => ComparisonOperator::NotEqual,
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a relational expression. '<', '<=', '>', '>='
    fn parse_relational_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.bitwise_or_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::LessThan)
            || tokens.at().token == TokenType::Operator(Operator::LessOrEqual)
            || tokens.at().token == TokenType::Operator(Operator::GreaterThan)
            || tokens.at().token == TokenType::Operator(Operator::GreaterOrEqual)
        {
            let op = tokens.eat().token.clone();
            let rhs = self.bitwise_or_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Comparison(ComparisonOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::LessThan) => ComparisonOperator::LessThan,
                    TokenType::Operator(Operator::LessOrEqual) => {
                        ComparisonOperator::LessThanOrEqual
                    }
                    TokenType::Operator(Operator::GreaterThan) => ComparisonOperator::GreaterThan,
                    TokenType::Operator(Operator::GreaterOrEqual) => {
                        ComparisonOperator::GreaterThanOrEqual
                    }
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a bitwise OR expression. '|'
    fn bitwise_or_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.bitwise_xor_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::Pipe) {
            let op = tokens.eat().token.clone();
            let rhs = self.bitwise_xor_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Binary(BinaryOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::Pipe) => BinaryOperator::BitOr,
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a bitwise XOR expression. '^'
    fn bitwise_xor_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.bitwise_and_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::BitwiseXor) {
            let op = tokens.eat().token.clone();
            let rhs = self.bitwise_and_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Binary(BinaryOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::BitwiseXor) => BinaryOperator::BitXor,
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a bitwise AND expression. '&'
    fn bitwise_and_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.bitwise_shift_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::BitwiseAnd) {
            let op = tokens.eat().token.clone();
            let rhs = self.bitwise_shift_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Binary(BinaryOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::BitwiseAnd) => BinaryOperator::BitAnd,
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a bitwise shift expression. '<<', '>>'
    fn bitwise_shift_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.additive_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::ShiftLeft)
            || tokens.at().token == TokenType::Operator(Operator::ShiftRight)
        {
            let op = tokens.eat().token.clone();
            let rhs = self.additive_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Binary(BinaryOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::ShiftLeft) => BinaryOperator::BitLeftShift,
                    TokenType::Operator(Operator::ShiftRight) => BinaryOperator::BitRightShift,
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses an additive expression. '+', '-'
    fn additive_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.multiplicative_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::Add)
            || tokens.at().token == TokenType::Operator(Operator::Subtract)
        {
            let op = tokens.eat().token.clone();
            let rhs = self.multiplicative_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Binary(BinaryOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::Add) => BinaryOperator::Add,
                    TokenType::Operator(Operator::Subtract) => BinaryOperator::Sub,
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a multiplicative expression. '*', '/', '%'
    fn multiplicative_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let mut lhs = self.parse_type_cast_expression(tokens)?;

        while tokens.at().token == TokenType::Operator(Operator::Multiply)
            || tokens.at().token == TokenType::Operator(Operator::Divide)
            || tokens.at().token == TokenType::Operator(Operator::Modulus)
        {
            let op = tokens.eat().token.clone();
            let rhs = self.parse_type_cast_expression(tokens)?;

            lhs = Expr::Operator(OperatorExpr::Binary(BinaryOperatorExpr {
                lhs: Box::new(lhs),
                op: match op {
                    TokenType::Operator(Operator::Multiply) => BinaryOperator::Mul,
                    TokenType::Operator(Operator::Divide) => BinaryOperator::Div,
                    TokenType::Operator(Operator::Modulus) => BinaryOperator::Mod,
                    _ => unreachable!(),
                },
                rhs: Box::new(rhs),
                span: tokens.at().span,
            }))
        }

        Some(lhs)
    }

    /// Parses a type cast expression. 'as'
    fn parse_type_cast_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let lhs = self.unary_expression(tokens)?;

        if tokens.at().token == TokenType::Keyword(Keyword::As) {
            tokens.eat(); // Consume 'as'

            let ty = self.parse_type_declaration(tokens)?;

            Some(Expr::Operator(OperatorExpr::TypeCast(
                TypeCastOperatorExpr {
                    expr: Box::new(lhs),
                    ty: ty.kind,
                    span: tokens.at().span,
                },
            )))
        } else {
            Some(lhs)
        }
    }

    /// Parses a unary expression. '+', '-', '!', '~'
    fn unary_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        if tokens.at().token == TokenType::Operator(Operator::Add)
            || tokens.at().token == TokenType::Operator(Operator::Subtract)
            || tokens.at().token == TokenType::Operator(Operator::LogicalNot)
            || tokens.at().token == TokenType::Operator(Operator::BitwiseNot)
            || tokens.at().token == TokenType::Operator(Operator::Multiply)
            || tokens.at().token == TokenType::Keyword(Keyword::Ref)
            || tokens.at().token == TokenType::Keyword(Keyword::MutRef)
        {
            let op = tokens.eat().token.clone();
            let expr = self.unary_expression(tokens)?;

            Some(Expr::Operator(OperatorExpr::Unary(UnaryOperatorExpr {
                op: match op {
                    TokenType::Operator(Operator::LogicalNot) => UnaryOperator::Not,
                    TokenType::Operator(Operator::BitwiseNot) => UnaryOperator::BitNot,
                    TokenType::Operator(Operator::Subtract) => UnaryOperator::Neg,
                    TokenType::Operator(Operator::Add) => UnaryOperator::Pos,
                    TokenType::Operator(Operator::Multiply) => UnaryOperator::Deref,
                    TokenType::Keyword(Keyword::Ref) => UnaryOperator::Ref,
                    TokenType::Keyword(Keyword::MutRef) => UnaryOperator::MutRef,
                    _ => unreachable!(),
                },
                expr: Box::new(expr),
                span: tokens.at().span,
            })))
        } else {
            self.parse_propagator_expression(tokens)
        }
    }

    /// Parses a propagator expression. '?'
    fn parse_propagator_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let lhs = self.parse_array_index_expression(tokens)?;

        if tokens.at().token == TokenType::Operator(Operator::QuestionMark)
            || tokens.at().token == TokenType::Operator(Operator::DoubleExclamation)
        {
            let op = tokens.eat().token.clone(); // Consume propagator operator

            Some(Expr::Operator(OperatorExpr::Propagator(
                PropagatorOperatorExpr {
                    expr: Box::new(lhs),
                    op: match op {
                        TokenType::Operator(Operator::QuestionMark) => {
                            PropagatorOperator::Propagate
                        }
                        TokenType::Operator(Operator::DoubleExclamation) => {
                            PropagatorOperator::Unwrap
                        }
                        _ => unreachable!(),
                    },
                    span: tokens.at().span,
                },
            )))
        } else if tokens.at().token == TokenType::Operator(Operator::DoubleQuestion) {
            tokens.eat(); // Consume propagator operator

            let rhs = self.parse_expression(tokens)?;

            Some(Expr::Operator(OperatorExpr::Propagator(
                PropagatorOperatorExpr {
                    expr: Box::new(lhs),
                    op: PropagatorOperator::Default(Box::new(rhs)),
                    span: tokens.at().span,
                },
            )))
        } else {
            Some(lhs)
        }
    }

    /// Parses an array index expression. 'T[0]'
    fn parse_array_index_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let lhs = self.parse_function_call_expression(tokens)?;

        if tokens.at().token == TokenType::Symbol(Symbol::LeftBracket) {
            tokens.eat(); // Consume '['

            let index = self.parse_expression(tokens)?;

            tokens.expect(
                TokenType::Symbol(Symbol::RightBracket),
                self.compilation_report,
            );

            Some(Expr::ArrayIndex(ArrayIndexExpr {
                array: Box::new(lhs),
                index: Box::new(index),
                span: tokens.at().span,
            }))
        } else {
            Some(lhs)
        }
    }

    /// Parse function call expression. 'foo()'
    fn parse_function_call_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let lhs = self.parse_field_access_expression(tokens)?;

        if tokens.at().token == TokenType::Symbol(Symbol::LeftParen) {
            tokens.eat(); // Consume '('

            let args = self.parse_call_arguments(tokens)?;

            Some(Expr::FuncCall(FuncCallExpr {
                func: Box::new(lhs),
                args,
                span: tokens.at().span,
            }))
        } else {
            Some(lhs)
        }
    }

    /// Parse field access or tuple index expression. 'foo.bar', 'foo.0'
    fn parse_field_access_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let lhs = self.parse_method_call_expression(tokens)?;

        if tokens.at().token == TokenType::Symbol(Symbol::Dot) {
            tokens.eat(); // Consume '.'

            match &tokens.eat().token {
                TokenType::Identifier(ident) => {
                    // Field Access 'foo.bar'
                    let field = ident.clone();

                    Some(Expr::FieldAccess(FieldAccessExpr {
                        expr: Box::new(lhs),
                        field,
                        span: tokens.at().span,
                    }))
                }
                TokenType::IntegerLiteral(index) => {
                    // Tuple Index 'foo.0'
                    let index: &i64 = index;

                    Some(Expr::TupleIndex(TupleIndexExpr {
                        tuple: Box::new(lhs),
                        index: *index as usize,
                        span: tokens.at().span,
                    }))
                }
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "field name".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected a field name.".to_string()],
                        }));
                    None
                }
            }
        } else {
            Some(lhs)
        }
    }

    /// Parses a method call expression. 'foo.bar()' (note difference from '(foo.bar)()',
    /// which is a function call on a value that is callable, not a method.)
    fn parse_method_call_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let lhs = self.parse_primary_expression(tokens)?;

        if tokens.at().token == TokenType::Symbol(Symbol::LeftParen) {
            tokens.eat(); // Consume '('

            let args = self.parse_call_arguments(tokens)?;

            Some(Expr::MethodCall(MethodCallExpr {
                method: Box::new(lhs),
                args,
                span: tokens.at().span,
            }))
        } else {
            Some(lhs)
        }
    }

    /// Parses a primary expression. This is the base case for the expression parser.
    fn parse_primary_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        // Peek at the current token without consuming it
        let token = tokens.at();
        let span = token.span;

        match &token.token {
            TokenType::IntegerLiteral(_)
            | TokenType::FloatLiteral(_)
            | TokenType::StringLiteral(_) => {
                // For literals, consume the token and create the literal expression
                let token = tokens.eat(); // Mutable borrow starts and ends here
                match &token.token {
                    TokenType::IntegerLiteral(value) => Some(Expr::Literal(LiteralExpr {
                        value: Literal::Integer(*value),
                        span,
                    })),
                    TokenType::FloatLiteral(value) => Some(Expr::Literal(LiteralExpr {
                        value: Literal::Float(*value),
                        span,
                    })),
                    TokenType::StringLiteral(value) => Some(Expr::Literal(LiteralExpr {
                        value: Literal::String(value.clone()),
                        span,
                    })),
                    _ => unreachable!(),
                }
            }
            TokenType::Identifier(_) => {
                // For identifiers, we may need to parse an expression path or variable
                self.parse_expr_path(tokens)
            }
            TokenType::Symbol(Symbol::LeftParen) => {
                tokens.eat(); // Consume '('
                let expr = self.parse_expression(tokens)?;
                tokens.expect(
                    TokenType::Symbol(Symbol::RightParen),
                    self.compilation_report,
                );
                Some(expr)
            }
            TokenType::Symbol(Symbol::LeftBracket) => {
                tokens.eat(); // Consume '['
                let elements = self.parse_array_values(tokens)?;
                Some(Expr::Array(ArrayExpr {
                    values: elements,
                    span,
                }))
            }
            TokenType::Keyword(Keyword::List) => {
                tokens.eat(); // Consume 'list'
                tokens.expect(
                    TokenType::Symbol(Symbol::LeftBracket),
                    self.compilation_report,
                );
                let elements = self.parse_array_values(tokens)?;
                Some(Expr::ListArray(ListArrayExpr {
                    values: elements,
                    span,
                }))
            }
            TokenType::Keyword(Keyword::If) => self.parse_if_expression(tokens),
            _ => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "expression".to_string(),
                        found: token.token.clone(),
                        span: token.span,
                        suggestion: vec!["Expected an expression.".to_string()],
                    }));
                None
            }
        }
    }

    /// Parses an expression path or variable reference.
    /// Expr Paths are used to represent variable references, function calls, etc.
    /// Only used in expressions.
    fn parse_expr_path(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        // Consume the identifier
        let token = tokens.eat();
        let ident = match &token.token {
            TokenType::Identifier(name) => name,
            other => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "identifier".to_string(),
                        found: other.clone(),
                        span: token.span,
                        suggestion: vec!["Expected an identifier.".to_string()],
                    }));
                return None;
            }
        };
        let span = token.span;
        // Mutable borrow from tokens.eat() ends here

        let mut path_segments = vec![ExprPathSegment {
            name: ident.clone(),
            args: vec![],
            span,
        }];

        // Handle paths with '::'
        while tokens.at().token == TokenType::Symbol(Symbol::DoubleColon) {
            tokens.eat(); // Consume '::'

            let token = tokens.eat().clone();
            let ident = match &token.token {
                TokenType::Identifier(name) => name,
                other => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "identifier".to_string(),
                            found: other.clone(),
                            span: token.span,
                            suggestion: vec!["Expected an identifier after '::'.".to_string()],
                        }));
                    return None;
                }
            };
            let ident_span = token.span;
            // Mutable borrow from tokens.eat() ends here

            // Parse generic arguments if any
            let args = {
                let token = tokens.at().token.clone();
                if token == TokenType::Operator(Operator::LessThan) {
                    tokens.eat(); // Consume '<'
                    let args = self.parse_generic_arguments(tokens)?;
                    tokens.expect(
                        TokenType::Operator(Operator::GreaterThan),
                        self.compilation_report,
                    );
                    args
                } else {
                    vec![]
                }
            };

            path_segments.push(ExprPathSegment {
                name: ident.to_string(),
                args,
                span: ident_span,
            });
        }

        Some(Expr::Path(ASTExprPath {
            segments: path_segments,
            span,
        }))
    }

    /// Parses generic arguments, e.g., `<T, U>`.
    fn parse_generic_arguments(&mut self, tokens: &mut Tokens) -> Option<Vec<ASTType>> {
        tokens.eat(); // Consume '<'
        let mut args = Vec::new();
        while tokens.at().token != TokenType::Operator(Operator::GreaterThan) {
            let arg = self.parse_type_declaration(tokens)?;
            args.push(arg);
            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat(); // Consume ','
            } else {
                break;
            }
        }
        tokens.expect(
            TokenType::Operator(Operator::GreaterThan),
            self.compilation_report,
        );
        Some(args)
    }

    /// Parses function call arguments.
    fn parse_call_arguments(&mut self, tokens: &mut Tokens) -> Option<Vec<Expr>> {
        tokens.expect(
            TokenType::Symbol(Symbol::LeftParen),
            self.compilation_report,
        );

        let mut args = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightParen) && tokens.not_eof() {
            let arg = self.parse_expression(tokens)?;
            args.push(arg);

            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            } else {
                break;
            }
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightParen),
            self.compilation_report,
        );

        Some(args)
    }

    /// Parses array values.
    ///
    /// **NOTE:** Ensure you have already consumed the opening '[' before calling this function.
    fn parse_array_values(&mut self, tokens: &mut Tokens) -> Option<Vec<Expr>> {
        let mut elements = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightBracket) && tokens.not_eof() {
            let element = self.parse_expression(tokens)?;
            elements.push(element);

            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            } else {
                break;
            }
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightBracket),
            self.compilation_report,
        );

        Some(elements)
    }

    /// Parses an if expression.
    fn parse_if_expression(&mut self, tokens: &mut Tokens) -> Option<Expr> {
        let if_span = tokens.at().span;
        tokens.eat(); // Consume 'if'

        // Parse condition
        let condition = self.parse_expression(tokens)?;

        // Parse then block
        let then_block = self.parse_block(tokens)?;

        // Optional else block
        let else_block = if tokens.at().token == TokenType::Keyword(Keyword::Else) {
            tokens.eat(); // Consume 'else'
            if tokens.at().token == TokenType::Keyword(Keyword::If) {
                // Else if
                Some(Box::new(self.parse_if_expression(tokens)?))
            } else {
                // Else block
                Some(Box::new(Expr::Block(self.parse_block(tokens)?)))
            }
        } else {
            None
        };

        Some(Expr::If(IfExpr {
            cond: Box::new(condition),
            then_block: Box::new(Expr::Block(then_block)),
            else_block,
            span: if_span,
        }))
    }

    fn parse_module_struct(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Struct> {
        // Consume 'struct'
        tokens.eat();

        // Parse struct name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "struct name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a struct name.".to_string()],
                    }));
                return None;
            }
        };

        // Parse struct fields
        tokens.expect(
            TokenType::Symbol(Symbol::LeftBrace),
            self.compilation_report,
        );

        let mut fields = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightBrace) && tokens.not_eof() {
            // Parse field visibility
            let field_visibility = self.parse_visibility(tokens);

            // Parse field name
            let field_name = match &tokens.eat().token {
                TokenType::Identifier(ident) => ident.clone(),
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "field name".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected a field name.".to_string()],
                        }));
                    return None;
                }
            };

            tokens.expect(TokenType::Symbol(Symbol::Colon), self.compilation_report);

            // Parse field type
            let field_type = self.parse_type_declaration(tokens)?;

            // Check for comma
            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            }

            fields.push(StructField {
                name: field_name,
                ty: field_type.kind,
                visibility: field_visibility,
            });
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightBrace),
            self.compilation_report,
        );

        Some(Struct {
            name,
            fields,
            generics: vec![], // Generics parsing not implemented here
        })
    }

    fn parse_module_enum(&mut self, _visibility: Visibility, tokens: &mut Tokens) -> Option<Enum> {
        tokens.eat(); // Consume 'enum'

        // Parse enum name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "enum name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected an enum name.".to_string()],
                    }));
                return None;
            }
        };

        // Parse enum variants
        tokens.expect(
            TokenType::Symbol(Symbol::LeftBrace),
            self.compilation_report,
        );

        let mut variants = Vec::new();

        while tokens.at().token != TokenType::Symbol(Symbol::RightBrace) && tokens.not_eof() {
            // Parse variant name
            let variant_name = match &tokens.eat().token {
                TokenType::Identifier(ident) => ident.clone(),
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "variant name".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected a variant name.".to_string()],
                        }));
                    return None;
                }
            };

            // For simplicity, we won't parse variant fields here
            // Check for comma
            if tokens.at().token == TokenType::Symbol(Symbol::Comma) {
                tokens.eat();
            }

            variants.push(EnumVariant {
                name: variant_name,
                fields: EnumField::None,
            });
        }

        tokens.expect(
            TokenType::Symbol(Symbol::RightBrace),
            self.compilation_report,
        );

        Some(Enum {
            name,
            variants,
            generics: vec![], // Generics parsing not implemented here
        })
    }

    fn parse_module_type_alias(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<TypeAlias> {
        tokens.eat(); // Consume 'type'

        // Parse type alias name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "type alias name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a type alias name.".to_string()],
                    }));
                return None;
            }
        };

        tokens.expect(
            TokenType::Operator(Operator::Assign),
            self.compilation_report,
        );

        // Parse the aliased type
        let ty = self.parse_type_declaration(tokens)?;

        tokens.expect(
            TokenType::Symbol(Symbol::Semicolon),
            self.compilation_report,
        );

        Some(TypeAlias {
            name,
            ty: ty.kind,
            generics: vec![],
        })
    }

    fn parse_module_trait(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Trait> {
        // For brevity, we'll not implement trait parsing here
        tokens.eat(); // Consume 'trait'
        tokens.eat(); // Consume trait name
                      // Skip the trait body
        None
    }

    fn parse_module_impl(&mut self, _visibility: Visibility, tokens: &mut Tokens) -> Option<Impl> {
        // For brevity, we'll not implement impl parsing here
        tokens.eat(); // Consume 'impl'
                      // Skip the impl body
        None
    }

    fn parse_module_const(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Const> {
        tokens.eat(); // Consume 'const'

        // Parse const name
        let name = match &tokens.eat().token {
            TokenType::Identifier(ident) => ident.clone(),
            token => {
                self.compilation_report
                    .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                        expected: "const name".to_string(),
                        found: token.clone(),
                        span: tokens.at().span,
                        suggestion: vec!["Expected a constant name.".to_string()],
                    }));
                return None;
            }
        };

        tokens.expect(TokenType::Symbol(Symbol::Colon), self.compilation_report);

        // Parse const type
        let ty = self.parse_type_declaration(tokens)?;

        tokens.expect(
            TokenType::Operator(Operator::Assign),
            self.compilation_report,
        );

        // Parse const value
        let value = self.parse_expression(tokens)?;

        tokens.expect(
            TokenType::Symbol(Symbol::Semicolon),
            self.compilation_report,
        );

        Some(Const {
            name,
            visibility: Visibility::Private, // Assuming private for now
            ty: ty.kind,
            value,
        })
    }

    fn parse_module_global(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
    ) -> Option<Global> {
        // For brevity, we'll not implement global variable parsing here
        tokens.eat(); // Consume 'global'
        None
    }

    fn parse_module_mod(
        &mut self,
        _visibility: Visibility,
        tokens: &mut Tokens,
        current_file_id: usize,
    ) -> Option<Module> {
        tokens.eat(); // Consume 'mod'

        // Parse module name
        let (name, name_span) = {
            let name_token = tokens.eat();
            let name = match &name_token.token {
                TokenType::Identifier(ident) => ident.clone(),
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "module name".to_string(),
                            found: token.clone(),
                            span: name_token.span,
                            suggestion: vec!["Expected a module name.".to_string()],
                        }));
                    return None;
                }
            };
            let name_span = name_token.span;
            (name, name_span)
        }; // `name_token` goes out of scope here

        if tokens.at().token == TokenType::Symbol(Symbol::LeftBrace) {
            tokens.eat(); // Consume '{'

            // Create new module and parse module block
            let mut submodule = Module {
                name: name.clone(),
                items: vec![],
                submodules: vec![],
            };

            while tokens.at().token != TokenType::Symbol(Symbol::RightBrace) && tokens.not_eof() {
                let item = self.parse_module_item(tokens, &mut submodule, current_file_id);
                if let Some(item) = item {
                    submodule.items.push(item);
                }
            }

            tokens.expect(
                TokenType::Symbol(Symbol::RightBrace),
                self.compilation_report,
            );

            Some(submodule)
        } else {
            // Expect a semicolon
            tokens.expect(
                TokenType::Symbol(Symbol::Semicolon),
                self.compilation_report,
            );

            // External module
            // Get current file path
            let current_file = self.file_store.get_file(current_file_id).unwrap();

            let current_file_path = std::path::Path::new(&current_file.name);

            // Get the directory of the current file
            let current_dir = current_file_path.parent().unwrap();

            // Possible module file paths
            // 1. current_dir / name + ".quik"
            // 2. current_dir / name / "mod.quik"

            let module_file_path1 = current_dir.join(format!("{}.quik", name));
            let module_file_path2 = current_dir.join(&name).join("mod.quik");

            // Convert module file paths to strings relative to project root
            let module_file_name1 = module_file_path1.to_string_lossy().to_string();
            let module_file_name2 = module_file_path2.to_string_lossy().to_string();

            // Check if module file exists in file store
            #[allow(unused_assignments)] // Assigning `module_file_id` in the `if` block
            let mut module_file_id = None;

            if let Some(file) = self.file_store.get_file_by_name(&module_file_name1) {
                module_file_id = Some(file.id);
            } else if let Some(file) = self.file_store.get_file_by_name(&module_file_name2) {
                module_file_id = Some(file.id);
            } else {
                // Try to load the file from the filesystem
                if module_file_path1.exists() {
                    let source = std::fs::read_to_string(&module_file_path1)
                        .expect("Failed to read module file");
                    let file_id = self.file_store.add_file(module_file_name1.clone(), source);
                    module_file_id = Some(file_id);
                } else if module_file_path2.exists() {
                    let source = std::fs::read_to_string(&module_file_path2)
                        .expect("Failed to read module file");
                    let file_id = self.file_store.add_file(module_file_name2.clone(), source);
                    module_file_id = Some(file_id);
                } else {
                    // Error: Module file not found
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::ModuleNotFound {
                            module_name: name.clone(),
                            span: name_span, // Use the cloned `name_span`
                            suggestion: vec![format!(
                                "Expected module file at {} or {}",
                                module_file_name1, module_file_name2
                            )],
                        }));
                    return None;
                }
            }

            let module_file_id = module_file_id.unwrap();

            // Check if the module has already been parsed
            if let Some(module) = self.parsed_modules.get(&module_file_id) {
                return Some(module.clone());
            }

            // Parse the external module file
            let module = self.parse_module_file(module_file_id)?;

            Some(module)
        }
    }

    fn parse_module_use(&mut self, _visibility: Visibility, tokens: &mut Tokens) -> Option<Use> {
        tokens.eat(); // Consume 'use'

        // Parse module path
        let path = self.parse_simple_path(tokens)?;

        // Check for alias
        let alias = if tokens.at().token == TokenType::Keyword(Keyword::As) {
            tokens.eat(); // Consume 'as'
            match &tokens.eat().token {
                TokenType::Identifier(ident) => Some(ident.clone()),
                token => {
                    self.compilation_report
                        .add_error(CompilerError::ParserError(ParserError::UnexpectedToken {
                            expected: "alias name".to_string(),
                            found: token.clone(),
                            span: tokens.at().span,
                            suggestion: vec!["Expected an alias name.".to_string()],
                        }));
                    return None;
                }
            }
        } else {
            None
        };

        tokens.expect(
            TokenType::Symbol(Symbol::Semicolon),
            self.compilation_report,
        );

        Some(Use {
            path,
            alias,
            glob: false,
        })
    }
}
